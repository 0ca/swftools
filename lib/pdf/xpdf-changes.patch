196c196
<     goto err1;
---
>     return start;
211c211
<   int nDigits, n1, n2, n3;
---
>   int maxCode, n1, n2, n3;
217c217
<   nDigits = nBits / 4;
---
>   maxCode = (nBits == 8) ? 0xff : (nBits == 16) ? 0xffff : 0xffffffff;
244c244
< 	if (!(n1 == 2 + nDigits && tok1[0] == '<' && tok1[n1 - 1] == '>' &&
---
> 	if (!(tok1[0] == '<' && tok1[n1 - 1] == '>' &&
246c246
< 	  error(-1, "Illegal entry in bfchar block in ToUnicode CMap");
---
> 	  error(-1, "Illegal entry in bfchar block in ToUnicode CMap.");
253a254,256
>         if (code1 > maxCode) {
>           error(-1, "Invalid entry in bfchar block in ToUnicode CMap");
>         }
269,270c272,273
< 	if (!(n1 == 2 + nDigits && tok1[0] == '<' && tok1[n1 - 1] == '>' &&
< 	      n2 == 2 + nDigits && tok2[0] == '<' && tok2[n2 - 1] == '>')) {
---
> 	if (!(tok1[0] == '<' && tok1[n1 - 1] == '>' &&
> 	      tok2[0] == '<' && tok2[n2 - 1] == '>')) {
279a283,286
>         if (code1 > maxCode || code2 > maxCode) {
> 	    error(-1, "Invalid entry in bfrange block in ToUnicode CMap");
> 	}
> 
60c60
<   startPage(0, NULL);
---
>   startPage(0, NULL, 0,0,0,0);
598a599
>     if(!n || n>16) n=16;
457c457,461
<   out->startPage(pageNum, state);
---
>   if(cropBox) {
>       out->startPage(pageNum, state, cropBox->x1,cropBox->y1,cropBox->x2,cropBox->y2);
>   } else {
>       out->startPage(pageNum, state, 0,0,0,0);
>   }
467a472
> #ifdef XPDFEXE
477a483
> #endif
3185,3186c3191,3195
<       if (n == 1 && *p == ' ') {
< 	dx += state->getWordSpace();
---
>       if (n == 1 && (*p == ' ' || *p == 0)) {
>         double w=state->getWordSpace();
>         if (w==0 && dx==0)
>           w=state->getFontSize()/3; // workaround for zero word space
>         dx += w;
3479c3488
<       colorSpace = GfxColorSpace::parse(&obj1);
---
>       colorSpace = GfxColorSpace::parse(&obj1, csMode);
3483a3493,3494
>     } else if (csMode == streamCSDeviceRGBX) {
>       colorSpace = new GfxDeviceRGBXColorSpace();
3826a3838
>   GfxState*old_state = state;
3837a3850,3852
>     // restore graphics state
>     while(state != old_state)
> 	restoreState();
921a922,925
> CharCodeToUnicode* Gfx8BitFont::getCTU() {
>     return ctu;
> }
> 
1413a1418,1421
> CharCodeToUnicode* GfxCIDFont::getCTU() {
>     return ctu;
> }
> 
166a167
>   virtual CharCodeToUnicode* getCTU() = 0;
206a208
>   virtual CharCodeToUnicode* getCTU();
215c217
<   char *getCharName(int code) { return enc[code]; }
---
>   char *getCharName(int code) { return code>=256?0:enc[code]; }
268a271
>   virtual CharCodeToUnicode* getCTU();
23a24
> #include "cmyk.h"
95c96
< GfxColorSpace *GfxColorSpace::parse(Object *csObj) {
---
> GfxColorSpace *GfxColorSpace::parse(Object *csObj, StreamColorSpaceMode csMode) {
104c105,108
<       cs = new GfxDeviceRGBColorSpace();
---
>       if(csMode == streamCSDeviceRGBX)
> 	cs = new GfxDeviceRGBXColorSpace();
>       else
> 	cs = new GfxDeviceRGBColorSpace();
117c121,124
<       cs = new GfxDeviceRGBColorSpace();
---
>       if(csMode == streamCSDeviceRGBX)
>         cs = new GfxDeviceRGBColorSpace();
>       else
> 	cs = new GfxDeviceRGBColorSpace();
335a343,353
> // GfxDeviceRGBXColorSpace
> //------------------------------------------------------------------------
> 
> GfxDeviceRGBXColorSpace::GfxDeviceRGBXColorSpace() {
> }
> 
> GfxColorSpace *GfxDeviceRGBXColorSpace::copy() {
>   return new GfxDeviceRGBXColorSpace();
> }
> 
> //------------------------------------------------------------------------
492a511,522
> /*void GfxDeviceCMYKColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {
>     unsigned char r,g,b;
>     float c = color->c[0];
>     float m = color->c[1];
>     float y = color->c[2];
>     float k = color->c[3];
>     convert_cmyk2rgb(c,m,y,k, &r,&g,&b);
>     rgb->r = r/255.0;
>     rgb->g = g/255.0;
>     rgb->b = b/255.0;
> }*/
> 
3189a3220
>   int maxPixelForAlloc;
3201a3233
>   maxPixelForAlloc = (1 << (bits>8?bits:8));
3256c3288
<       lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,
---
>       lookup[k] = (GfxColorComp *)gmallocn(maxPixelForAlloc + 1,
3275c3307
<       lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,
---
>       lookup[k] = (GfxColorComp *)gmallocn(maxPixelForAlloc + 1,
3285c3317
<       lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,
---
>       lookup[k] = (GfxColorComp *)gmallocn(maxPixelForAlloc + 1,
3756a3789,3790
>   if(pathA) {
>       if(path)
3757a3792
>   }
141c141
<   static GfxColorSpace *parse(Object *csObj);
---
>   static GfxColorSpace *parse(Object *csObj, StreamColorSpaceMode csMode = streamCSNone);
254a255,267
> // GfxDeviceRGBXColorSpace
> //------------------------------------------------------------------------
> 
> class GfxDeviceRGBXColorSpace: public GfxDeviceRGBColorSpace {
> public:
> 
>   GfxDeviceRGBXColorSpace();
>   virtual GfxColorSpace *copy();
>   virtual int getNComps() { return 4; }
> private:
> };
> 
> //------------------------------------------------------------------------
916a917,939
>   /* extract path */
>   if(fileName) {
>     char* cfgFileName = fileName->getCString();
>     char* pos1 = strrchr(cfgFileName, '/');
>     char* pos2 = strrchr(cfgFileName, '\\');
>     char* p = pos1>pos2?pos1:pos2;
>     int pos = p ? p-cfgFileName : -1;
>     GString*path = new GString(new GString(cfgFileName), 0, (pos < 0 ? strlen(cfgFileName): pos));
>     if(pos1>=0)
> 	path->append('/');
>     else if(pos2>=0)
> 	path->append('\\');
>     else
> #ifdef WIN32
> 	path->append('\\');
> #else
> 	path->append('/');
> #endif
>     this->path = path;
>   } else {
>     this->path = new GString();
>   }
>   
1116a1140,1175
> static char is_absolute(char*filename)
> {
>     int l = strlen(filename);
>     if(filename[0] == '/' || filename[0] == '\\') 
> 	return 1;
>     if(l>2 && filename[1]==':' && (filename[2]=='\\' || filename[2]=='/'))
> 	return 1;
>     return 0;
> }
> 
> static GString* qualify_filename(GString*path, GString*filename)
> {
>   GString*fullpath = 0;
>   char*prefix = "/usr/local/share/xpdf/";
> 
>   if (!is_absolute(filename->getCString())) {
>     /* relative path */
>     fullpath = path->copy();
>     fullpath->append(filename);
>   } else if (!strncmp(filename->getCString(), prefix, strlen(prefix))) {
>     /* xpdf default path */
>     char*s = strchr(filename->getCString()+strlen(prefix), '/');
>     if(s) {
> 	fullpath = path->copy();
> 	fullpath->append(s+1);
>     } else {
> 	fullpath = filename->copy();
>     }
>   } else {
>     /* absolute path */
>     fullpath = filename->copy();
>   }
>   //printf("%s -%s-> %s\n", filename->getCString(), path->getCString(), fullpath->getCString());
>   return fullpath;
> }
> 
1131c1190
<   name = (GString *)tokens->get(1);
---
>   name = qualify_filename(this->path, (GString *)tokens->get(1));
1133,1134c1192,1193
<     error(-1, "Couldn't open 'nameToUnicode' file '%s'",
< 	  name->getCString());
---
>     error(-1, "Couldn't open 'nameToUnicode' file '%s' using path '%s'",
> 	  name->getCString(), path->getCString());
1162a1222
> 
1166c1226,1227
<   cidToUnicodes->add(collection->copy(), name->copy());
---
> 
>   cidToUnicodes->add(collection->copy(), qualify_filename(this->path, name));
1183c1244,1245
<   unicodeToUnicodes->add(font->copy(), file->copy());
---
> 
>   unicodeToUnicodes->add(font->copy(), qualify_filename(this->path, file));
1200c1262,1263
<   unicodeMaps->add(encodingName->copy(), name->copy());
---
> 
>   unicodeMaps->add(encodingName->copy(), qualify_filename(this->path, name));
1218c1281,1282
<   list->append(dir->copy());
---
> 
>   list->append(qualify_filename(this->path, dir));
1222a1287,1288
>   GString *dir;
> 
1228c1294,1297
<   toUnicodeDirs->append(((GString *)tokens->get(1))->copy());
---
> 
>   dir = (GString *)tokens->get(1);
> 
>   toUnicodeDirs->append(qualify_filename(this->path, dir));
1234a1304
>   GString *file;
1246c1316,1317
<     param->t1.fileName = ((GString *)tokens->get(2))->copy();
---
>     file = (GString *)tokens->get(2);
>     param->t1.fileName = qualify_filename(this->path, file);
1252c1323,1324
<     param->tt.fileName = ((GString *)tokens->get(2))->copy();
---
>     file = (GString *)tokens->get(2);
>     param->tt.fileName = qualify_filename(this->path, file);
199c199
<   ~GlobalParams();
---
>   virtual ~GlobalParams();
216,217c216,217
<   DisplayFontParam *getDisplayFont(GString *fontName);
<   DisplayFontParam *getDisplayCIDFont(GString *fontName, GString *collection);
---
>   virtual DisplayFontParam *getDisplayFont(GString *fontName);
>   virtual DisplayFontParam *getDisplayCIDFont(GString *fontName, GString *collection);
319c319
<   void parseFile(GString *fileName, FILE *f);
---
> public: void parseFile(GString *fileName, FILE *f); private:
360a361,364
>   //----- config file base path
> 
>   GString*path;
> 
1517,1521c1517,1524
<   symCodeLen = 1;
<   i = (numInputSyms + numNewSyms) >> 1;
<   while (i) {
<     ++symCodeLen;
<     i >>= 1;
---
>   symCodeLen = 0;
>   i = 1;
>   while (i < numInputSyms + numNewSyms) {
>    ++symCodeLen;
>    i <<= 1;
>   }
>   if (huff && symCodeLen == 0) {
>    symCodeLen = 1;
1923a1927,1929
>   if (huff && symCodeLen == 0) {
>     symCodeLen = 1;
>   }
452a453
>   Guint num_components = 0;
466c467
< 	    readUWord(&dummy) &&
---
> 	    readUWord(&num_components) &&
521a523,525
>   if(*csMode == streamCSDeviceRGB && num_components == 4) {
>     *csMode = streamCSDeviceRGBX;
>   }
76a77
> static int illegalChars = 0;
85a87,89
>   if(illegalChars)
>       error(0, "Illegal characters in hex string (%d)", illegalChars);
>   illegalChars = 0;
333c337,338
< 	  error(getPos(), "Illegal digit in hex char in name");
---
> 	  illegalChars++;
> 	  //error(getPos(), "Illegal digit in hex char in name");
387,388c392,395
< 	  else
< 	    error(getPos(), "Illegal character <%02x> in hex string", c);
---
> 	  else {
> 	    illegalChars++;
> 	    //error(getPos(), "Illegal character <%02x> in hex string", c);
> 	  }
424c431,432
<       error(getPos(), "Illegal character '>'");
---
>       illegalChars++;
>       //error(getPos(), "Illegal character '>'");
433c441,442
<     error(getPos(), "Illegal character '%c'", c);
---
>     //error(getPos(), "Illegal character '%c'", c);
>     illegalChars++;
462d470
< 
433d432
< 
436c435
<     error(-1, "Illegal annotation destination");
---
>     error(-1, "Illegal annotation destination %d", destObj->getType());
471d469
< 
474c472
<     error(-1, "Illegal annotation destination");
---
>     error(-1, "Illegal annotation destination %d", destObj->getType());
19a20
> #include "Object.h"
97c98
<   virtual void startPage(int pageNum, GfxState *state) {}
---
>   virtual void startPage(int pageNum, GfxState *state, double x1,double y1,double x2,double y2) {}
48a49
>   
56a58,61
>  
>   this->ascender = face->ascender;
>   this->descender = face->descender;
> 
230a236,241
> int SplashFTFont::getNumChars()
> {
>   SplashFTFontFile* ff = (SplashFTFontFile *)fontFile;
>   return ff->face->num_glyphs;
> }
> 
251a263,264
>   this->last_advance = -1;
> 
265c278,280
<   if (FT_Load_Glyph(ff->face, gid, FT_LOAD_NO_BITMAP)) {
---
>   int error = 0;
>   if ((error=FT_Load_Glyph(ff->face, gid, FT_LOAD_NO_BITMAP|FT_LOAD_NO_HINTING))) {
>       fprintf(stderr, "Truetype wasn't able to load glyph %d, error %d\n", gid, error);
270a286,287
>   this->last_advance = glyph->advance.x/65536.0;
> 
274c291
<   FT_Outline_Decompose(&((FT_OutlineGlyph)glyph)->outline,
---
>   error = FT_Outline_Decompose(&((FT_OutlineGlyph)glyph)->outline,
275a293,295
>   if(error) {
>       fprintf(stderr, "Truetype wasn't able to read glyph %d, error %d\n", gid, error);
>   }
44a45,47
>   // return the number of characters in this font
>   virtual int getNumChars();
> 
16d15
< #ifndef WIN32
18d16
< #endif
50a51,54
> 
>   last_advance = -1;
>   ascender = -1;
>   descender = -1;
75a76,78
>   // return the number of characters in this font
>   virtual int getNumChars() = 0;
> 
85a89,91
>   double ascender;
>   double descender;
>   double last_advance; //set after getGlyphPath()
14,16c14
< #ifndef WIN32
< #  include <unistd.h>
< #endif
---
> #include <unistd.h>
15a16
> #include <unistd.h>
705c706
< void SplashOutputDev::startPage(int pageNum, GfxState *state) {
---
> void SplashOutputDev::startPage(int pageNum, GfxState *state, double x1,double y1,double x2,double y2) {
2649,2650c2650
<   memset(softMask->getDataPtr(), 0,
< 	 softMask->getRowSize() * softMask->getHeight());
---
>   memset(softMask->getDataPtr(), 0x00, softMask->getRowSize()*softMask->getHeight());
2651a2652
>   if (tx<softMask->getWidth() && ty<softMask->getHeight())
73c73
<   virtual void startPage(int pageNum, GfxState *state);
---
>   virtual void startPage(int pageNum, GfxState *state, double x1,double y1,double x2,double y2);
198a199,201
>   void doUpdateFont(GfxState *state);
>   
>   SplashPath *convertPath(GfxState *state, GfxPath *path);
207,208d209
<   SplashPath *convertPath(GfxState *state, GfxPath *path);
<   void doUpdateFont(GfxState *state);
365a366,367
>   return 1;
> 
397c397
< 	for (; xx + 7 <= xx0; xx += 8) {
---
> 	for (; xx + 7 < xx0; xx += 8) {
400c400
< 	if (xx <= xx0) {
---
> 	if (xx < xx0) {
420c420
<       for (; xx + 7 <= xx0; xx += 8) {
---
>       for (; xx + 7 < xx0; xx += 8) {
423c423
<       if (xx <= xx0) {
---
>       if (xx < xx0) {
20a21,22
> #else
> extern "C" int unlink(char *filename);
44c44,45
<   streamCSDeviceCMYK
---
>   streamCSDeviceCMYK,
>   streamCSDeviceRGBX
3880c3880
< void TextOutputDev::startPage(int pageNum, GfxState *state) {
---
> void TextOutputDev::startPage(int pageNum, GfxState *state, double x1,double y1,double x2,double y2) {
172a173
>   friend class XMLOutputDev;
581c582
<   virtual void startPage(int pageNum, GfxState *state);
---
>   virtual void startPage(int pageNum, GfxState *state, double x1,double y1,double x2,double y2);
441a442,487
> static char* getTempDir()
> {
> #ifdef WIN32
>     char*dir = getenv("TMP");
>     if(!dir) dir = getenv("TEMP");
>     if(!dir) dir = getenv("tmp");
>     if(!dir) dir = getenv("temp");
>     if(!dir) dir = "C:\\";
> #else
>     char* dir = "/tmp/";
> #endif
>     return dir;
> }
> 
> char* mktmpname(char*ptr) {
>     static char tmpbuf[128];
>     char*dir = getTempDir();
>     int l = strlen(dir);
>     char*sep = "";
>     if(!ptr)
> 	ptr = tmpbuf;
>     if(l && dir[l-1]!='/' && dir[l-1]!='\\') {
> #ifdef WIN32
> 	sep = "\\";
> #else
> 	sep = "/";
> #endif
>     }
> 
>  //   used to be mktemp. This does remove the warnings, but
>  //   It's not exactly an improvement.
> #ifdef HAVE_LRAND48
>     sprintf(ptr, "%s%s%08x%08x",dir,sep,(unsigned int)lrand48(),(unsigned int)lrand48());
> #else
> #   ifdef HAVE_RAND
> 	sprintf(ptr, "%s%s%08x%08x",dir,sep,rand(),rand());
> #   else
> 	static int count = 1;
> 	sprintf(ptr, "%s%s%08x%04x%04x",dir,sep,time(0),(unsigned int)tmpbuf^((unsigned int)tmpbuf)>>16,count);
> 	count ++;
> #   endif
> #endif
>      return ptr;
> }
> 
> 
463c509
<     sprintf(buf, "%d", t + i);
---
>     sprintf(buf, "%08x-%08x", t + i, GetCurrentThreadId());
471,472c517
< 	delete s;
< 	return gFalse;
---
>         continue;
481a527
>   fprintf(stderr, "Couldn't create temporary file\n");
492c538
<   if (!(s = tmpnam(NULL))) {
---
>   if (!(s = mktmpname(NULL))) {
519c565
<     if (!(s = tmpnam(NULL))) {
---
>     if (!(s = mktmpname(NULL))) {
536c582
<     if (!(s = tmpnam(NULL))) {
---
>     if (!(s = mktmpname(NULL))) {
60a61,63
> /* create a temporary filename */
> char* mktmpname(char*ptr);
> 
